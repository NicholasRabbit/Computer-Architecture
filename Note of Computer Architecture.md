### 一, 内存与地址

内存跟居民楼里的邮箱一样，邮箱都有一个房间编号，每个内存单元都有一个地址，CPU通过内存地址找到对应的内存单元，然后读取其中的数据或操作指令。但是一个内存地址对应的内存单元所存数据有限，只能存一个字节byte，即一个字节有一个内存地址。int, long等数据类型占用多个byte，那么这种类型的数据的内存地址就是它们所占内存单元的起始地址。

**小端保存，大端保存？**(参照C语言与此内容有关的笔记)

```txt
对于多字节的整数类型，低地址保存的是整数的低位，这称为小端（Little Endian）字节序（Byte Order）。x86平台是小端字节序的，而另外一些平台规定低地址保存整数的高位，称为大端（Big Endian）字节序。
```

### 二, CPU

1. CPU用来干什么？
   CPU总是周而复始的做一件事情：从内存读取指令，解释并执行，在读取下一条指令，解释并执行。
   这里的内存不仅指的是一般意义上的那种电脑内存，还有CPU内部的寄存器，缓存等等。
   常见寄存器：eax, esp, eip等。
2. CPU的核心功能组成部件：
   - Register: 寄存器，组装在CPU内部的存储部件，用来存储数据，指令等。
   
   - Program  Counter: 程序计数器，这是一种特殊的寄存器，保存的数据就是CPU准备要读取的指令的内存地址，CPU取得地址后，就去找对应内存中的指令，找到指令信息后给Instruction Decoder执行。
   
   - Instruction Decoder: 指令译码器，解释指令，CPU获取到的指令有很多中类型，有数据，内存地址，寄存器地址等。译码器负责翻译后，然后调用对应的执行单元去执行。
   
   - Arithmetic and Logic Unit: 算数逻辑单元，如果Instruction Decoder得到的指令是进行运算，则会调用ALU，执行加减乘除，位移等。同时过来的指令中含有运算结果的保存地址等信息。
   
   - Bus: CPU和内存之间的地址总线。 CPU和内存之间用地址总线、数据总线和控制线连接起来，每条线上有1和0两种状态 。
     具体参照：<a href="https://akaedu.github.io/book/ch17s02.html">《Linux C 一站式编程》17.2</a>
     操作流程：
   
     ```txt
     1, CPU内部将寄存器对接到数据总线上，使寄存器的每一位对接到一条数据线，等待接收数据。
     2, CPU通过控制线发一个读请求，并且将内存地址通过地址线发给内存。
     3, 内存收到地址和读请求之后，将相应的内存单元对接到数据总线的另一端，这样，内存单元每一位的1或0状态通过一条数据线到达CPU寄存器中相应的位，就完成了数据传送。
     ```
   
3. CPU执行过程总结
   CPU执行时有两条主线，一条是Program Counter，这里保存的是指令的地址，可能是按顺序保存的，CPU根据地址找到指令，然后把指令交给Instruction Decoder翻译，翻译后的结果可能是获取指定内存地址的数据，进行运算等。另一条是Register，保存程序的数据或者执行，供CPU使用。

### 三，加减运算表示

byte类型中用128\~255表示-128\~-1， 用0\~127还表示本数是2's Complement表示法。

### 四，Inaccurate double and float

```txt
/*
* float,double在计算式损失精度的原因：
* 1，float和double类型是为科学计算和工程计算设计的，他们执行二进制的浮点运算。
*    这使得他们能够在广泛的数值范围内提供更精确的快速近似和计算，但是不能提供完全准确的计算结果。
* 2，因为float,double是用科学计数法来表示数字的，不能表示任何有限长度的二进制，因此转换的时候就会有精度损失
* 3，精度损失是在二进制转换为十进制的时候损失的
*    例：0.5用二进制表示就是 0.5 x 2 = 1 ==> 0.1(二进制，小数点后的 1 x 2^-1 = 0.5)
        但0.2则无法用二进制拼起来，2^-3 = 1/8 = 0.125 ，2^-4 = 1/16 = 0.0625 ...这几个加起来永远无法刚好等于0.2，
		所以造成精度损失。

* 为什么小数位转换成二进制要乘以2？
* 跟小数点左边整数位除以2原理相同，左边转换为二进制，2是最小单位。
* 小数点右边0.0第一位是2^-1次方，因为刚好比1小，即1/2是最小单位，除以1/2就是乘以2，
* 例：0.26
* 0.26 x 2 = 0.52, 整数位是0，说明有0个2^-1，二进制中乘以2，相当于左移一位，跟十进制0.1415926 x 10 = 1.1415926同理，因此下面接着x2就是得到几个2^-2次方。
* 0.52 x 2 = 1.04, 整数位是1，1 x 2^-2次方，因为第二位小数的二进制值的出来了，需要减去这个二进制的1
* 0.04 x 2 = 0.08, ...
* 0.08 x 2 = 0.16, ...
* 然后就计算多少个1/2,1/4,1/8加起来正好等于小数位，
* 有时后永远无法等于，这就造成了精度损失。


* 解决办法：
* 3，使用BigDecimal来解决
* 因为BigDecimal的长度是不可变得，BigDecimal在处理的时候把十进制小数扩大N倍让它在整数上进行计算，并保留相应的精度信息
* 注意：不能直接把double类型的数作为BigDecimal构造函数的实参，转换结果有误
* 应换为String类型，见下例。
* 参考：https://cloud.tencent.com/developer/article/1468551
*		https://cloud.tencent.com/developer/article/1470383
*/

```

